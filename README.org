#+TITLE: CBC-padding Oracle Demonstration

The following simple client-server program illustrates the dangers of revealing padding errors, when using AES in CBC mode.

The TL;DR: Recall that a CBC ciphertext is

: C[0] || C[1] || ... || C[n]

where ~C[0]~ is the IV and

: C[i] = E(P[i] xor C[i-1])

Suppose the padding scheme used is PKCS#7. We can then decrypt block ~i~ in the following way:

Let ~c~ be a byte that we pick, define
: IV := C[i-1] xor c xor 0x01
: C  := C[i]
and send ~C=AB~ as the ciphertext to the oracle. When the oracle decrypts, it recovers
: F = D(C) xor IV
:   = I[i] xor C[i-1] xor c xor 0x01
:   = P[i] xor c xor 0x01

(Note the ~A~ acts as the IV. ~I[i]~ denotes the intermidiate value that the block cipher decryption algorithm ~D~ outputs.)
Suppose ~c~ was picked such that it matches the last byte of ~P[i]~.
Then in this case, ~P[i] xor c xor 0x01~ will be ~P[i]~ except with ~0x01~ at the end.
In particular, ~F~ has valid padding.
On the other hand, if ~c~ was incorrect, then with good probability, the padding of ~F~ will be incorrect as well.
Thus, if the oracle tells us whether or not the padding of ~F~ is correct, we can use it to guess the last byte of the plaintext.

It is straight forward to turn this into a procedure that decrypts the entire block:
when we've recovered ~c_n~ (the last byte), let our next choice be ~c_(n-1)||(c_n xor 0x02)~ and use ~0x02~ as the padding instead.
We know ~c_n~ matches, so when we get the "valid padding" response from the oracle, we learn
that the last two bytes of ~F~ is ~0x02 0x02~ and thus that our guess at ~c_(n-1)~ was correct.

* Server

  The server (~server.py~) is written in Python 2 and uses Flask.

  To run the server
  : $ python server.py

** Decryption game

   When the server starts it samples a random key K and constructs a
   flag F of the form
   : F = flag{hex(32 random bytes)}

   The server exposes 3 relevant routes that can be used to play the
   "decryption" game:
   | route name     | description                                                            |
   |----------------+------------------------------------------------------------------------|
   | encrypted_flag | Returns F                                                              |
   | decrypt?hex(C) | Returns /OK/ if ~D(k,C)~ has valid padding and /Bad padding/ otherwise |
   | test_flag?G    | Returns /Yay/ if ~F = G~ and /Boo/ otherwise                           |

   The goal is then to use the ~decrypt_flag~ route (since this is
   where the padding oracle is exposed) in order to decrypt the F
   recieved from ~encrypted_flag~.

   See ~client_dec.py~ for an implementation of a client who beats
   this game.

** Encryption game

   Given a P, the goal is to construct a valid ciphertext C such that
   D(k,C) = P.

   Relevant routes are
   | route name                   | description                           |
   |------------------------------+---------------------------------------|
   | decrypt?hex(C)               | Padding oracle (see previous section) |
   | test_encryption?e=hex(C)&d=t     | /Yay/ if ~D(k,C) = t~, /Boo/ otherwise |

   See ~client_enc.py~.

* References

  - Vaudenay, Serge. "Security flaws induced by CBC
    padding-applications to SSL, IPSEC, WTLS."
    EUROCRYPT. Vol. 2332. 2002.

  - Rizzo, Juliano, and Thai Duong. "Practical Padding Oracle
    Attacks." WOOT. 2010.
